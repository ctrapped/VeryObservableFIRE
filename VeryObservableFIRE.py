import numpy as np
import h5py as h5py
import os.path
import time

from joblib import Parallel, delayed
import multiprocessing
from multiprocessing import Pool

from functools import partial

from VOF_GenerateSightlineFiles import GenerateSightlineFiles
from VOF_parallel_iterate_sightlines import IterateSightlines

from matplotlib import pyplot as plt
from matplotlib.colors import LogNorm

pi = np.pi
arcsec = (1. /60. / 60.) * pi/180.

image=0

Joules2eV = 6.241509*np.power(10.0,18.0)
meters2Kpc = 3.24078*np.power(10.0,-20.0)
Jy2SimUnits = np.power(10.0,-26.0) * Joules2eV / meters2Kpc / meters2Kpc
#J*s^-1*m^-2*Hz-1
SimUnits2Jy = 1.0 / Jy2SimUnits 


####Each thread generates a spectra for the assigned pixel, then convolves it with a Gaussian PSF at it's location within the image.
####Returns a matrix the size of the image, containing soley the PSF contribution from the assigned sightline.
####This allows the total image to be created from summing each thread contribution.
####
####Written By Cameron Trapp (ctrapped@gmail.com)
####Updated 12/08/2023
            

def foo(thread_id,snapDir, sightlineDir, Nsnapstring,statsDir,speciesToRun,noiseAmplitude,beamSize,targetBeamSize,Nspec,bandwidth,output,Nsightlines1d,gaussianMat):
    t0=time.time()
    outputDir = output + "_spectra"+str(thread_id)+".hdf5" #Where to write synthetic images
    threadImage=np.zeros((Nsightlines1d,Nsightlines1d,Nspec)) #Image generated by this thread. Will fit the main pixel+PSF effects

    ix=thread_id % Nsightlines1d #Thread pixel coordinates
    iy = int(np.floor(thread_id / Nsightlines1d))
    
    sightlineDir_thread = sightlineDir + "_allSightlines.hdf5" #Directory Sightlines were written to

    threadImage[ix,iy,:]=IterateSightlines(thread_id,snapDir,Nsnapstring,statsDir,output,sightlineDir_thread,speciesToRun,beamSize,Nspec,bandwidth) #Generate Spectra
    threadImage[ix,iy,:] = threadImage[ix,iy,:] * SimUnits2Jy #Convert to Jy
    
    noiseProfile = np.random.normal(0, noiseAmplitude * beamSize / targetBeamSize, np.shape(threadImage)[2]) #Create noise profile scaled by the downsampling we are doing
    
    threadImage = ConvolveWithPSF(threadImage,ix,iy,gaussianMat) #Apply Gaussian PSF
    threadImage[ix,iy,:] = np.add(threadImage[ix,iy,:] , noiseProfile) #Add noise to pixel after smoothing
    
    print("Thread ",thread_id,": finished sightline in ",time.time()-t0)
    
    return threadImage



def GenerateSyntheticImage(fileDir,statsDir, Nsnap, output,sightlineDir,
                            observerDistance, observerVelocity,
                            maxRadius,
                            noiseAmplitude,beamSize,targetBeamSize,Nsightlines1d,
                            phiObs,inclination,
                            speciesToRun,Nspec,bandwidth,
                            savePNG,createSightlineFiles=True,bandwidth_km_s=None,
    ):
                                        
    t1 = time.time()
    Nsnapstring = str(Nsnap)     
    snapDir = fileDir+Nsnapstring #Directory containing the actual snapshots
    statsDir = statsDir+Nsnapstring.zfill(4)+".hdf5" #Centering/orientation information.
    
    Nsightlines=Nsightlines1d*Nsightlines1d

    print("Generating Sightline Files...")
    observer_position = np.array([-observerDistance, phiObs, 0]) #in spherical coordinates
    maxPhi = pi* maxRadius / observerDistance #Convert physical size of observation to radians on the sky
    maxTheta = maxPhi
    if maxTheta>pi: #You probably shouldn't ever look at an image this big anyway...
        maxTheta = pi
        
    maxima=[maxRadius,maxPhi,maxTheta]
    print("Beam size set to: ",beamSize /arcsec," ''")
    
    if createSightlineFiles:
        #Predefine which particles belong to which sightline files to speed up parallelization. Can be re-used for observations from the same distance/inclination
        GenerateSightlineFiles(snapDir,Nsnapstring,statsDir,observer_position,observerVelocity,sightlineDir,maxima,beamSize,Nsightlines,phiObs = phiObs, inclination = inclination) 
        
    gaussianMat = Generate_PSF_Matrix(Nsightlines1d,beamSize,targetBeamSize,Nspec) #Precalculate PSF matrix

        
    #### Start Paralellization ####
    runParallel=True  
    if runParallel:
        t2=time.time()
        print("Setting up Parallel Run...")
        num_cores = multiprocessing.cpu_count()-1


        foo_ = partial(foo, snapDir=snapDir, sightlineDir=sightlineDir, Nsnapstring=Nsnapstring, statsDir=statsDir,speciesToRun=speciesToRun,noiseAmplitude=noiseAmplitude,beamSize=beamSize,targetBeamSize=targetBeamSize,Nspec=Nspec,bandwidth=bandwidth,output=output,Nsightlines1d=Nsightlines1d,gaussianMat=gaussianMat)
        sightline_indices = range(0,Nsightlines)
        print("Working with ",num_cores," threads!")
        #Each Thread generates image for a given sightline
        x = Parallel(n_jobs=num_cores)(delayed(foo_)(i) for i in sightline_indices)
        #Combine thread images into the full image
        image = np.sum(x,0)
                 
        hf = h5py.File(output+'_fullSpectra.hdf5','w')
        hf.create_dataset('spectra',data=image)
        hf.close()
        print("Finished generating image in ",time.time()-t2," s")
        if savePNG: #Option to create a column density map to visualize results immediately
            fig = plt.figure()
            vmax = np.max(np.sum(image,2))
            vmin = vmax * np.power(10.0,-4.0)
            plt.imshow(np.sum(image,2),norm=LogNorm(vmin=vmin,vmax=vmax),cmap='inferno')
            plt.colorbar()
            plt.savefig(output+'_fullSpectra.png')
            
        if False and bandwidth_km_s is not None: #Experimental. Tried to reduce data size for ease of training by collapsing the spectral dimension. Didn't work amazingly.
            Nx,Ny,Nspec = np.shape(image)
            dopplerVel = np.linspace(-bandwidth_km_s/2 , bandwidth_km_s/2,Nspec)
            dopplerMF = np.zeros((Nx,Ny))
            for i in range(0,Nx):
                for j in range(0,Ny):
                    dopplerMF[i,j] = np.sum(np.multiply(image[i,j,:] , dopplerVel)) #Analog to mass flux
            hf = h5py.File(output+".hdf5",'w')
            hf.create_dataset('image',data=dopplerMF)
            hf.close()
            if savePNG:
                fig = plt.figure()
                vmax = np.max([-np.min(dopplerMF),np.max(dopplerMF)])
                vmin = -vmax
                plt.imshow(dopplerMF,vmin=vmin,vmax=vmax,cmap='seismic')
                plt.colorbar()
                plt.savefig(output+'.png')
                    
    else:
        #You should just run this in parallel
    	for i in range(0,Nsightlines):
            sightlineDir = output+"_sightline"+str(i)+".hdf5"
            output = output+"_spectra"+str(i)+".hdf5"
            image = np.add(image , IterateSightlines(snapDir,Nsnapstring,statsDir,output,sightlineDir,speciesToRun,beamSize,Nspec,bandwidths))
            
    print("Snapshot ",Nsnapstring," ran in ",time.time()-t1) 

   
   
def Generate_PSF_Matrix(Nsightlines1d,beamSize,targetBeamSize,Nspec):
    #Creates a gaussian matrix representing the psf that can be applied to every spectral entry
    #
    #For each bin convolve with psf(2-d gaussian kernel) and add result to modelImage 
    #lambda_k = stdv in k direction 
    #lambda_n = .stdv in n direction

    lambda_k = targetBeamSize / beamSize
    lambda_n = targetBeamSize / beamSize #way this is set up, should be about 1 px per beamsize...
    
    prefactor = 1/2/pi/lambda_k/lambda_n 
    
    gaussianMat = np.zeros((Nsightlines1d*2 , Nsightlines1d*2))
    x = np.indices(np.shape(gaussianMat))[0]
    y = np.indices(np.shape(gaussianMat))[1]
    
    xc = np.shape(gaussianMat)[0]/2
    yc = np.shape(gaussianMat)[1]/2
    
    gaussianMat = prefactor * np.exp(-0.5 * (np.power(x-xc,2)/lambda_k/lambda_k + np.power(y-yc,2)/lambda_n/lambda_n)) #add psf from pixel
    normCorrection = np.sum(gaussianMat)
    gaussianMat*=1/normCorrection #account for resolution limitations for a very small psf in this pixel space

    return np.repeat(gaussianMat[:,:,np.newaxis],Nspec,axis=2) #repeat for each spectral channel
    
def ConvolveWithPSF(image,ix,iy,gaussianMat):
    #Uses the location of the thread pixel with the pre-generated PSF to place appropriately in the final image
    #Efficient for high resolution images in parallel
    nx,ny,nspec = np.shape(image)
    newImage = np.multiply(image[ix,iy,:] , gaussianMat[(nx-ix):(2*nx-ix),(ny-iy):(2*ny-iy),:])
    return newImage

    

